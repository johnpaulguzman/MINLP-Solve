Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Users\pu>python C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py
  File "C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py", line 80
    S1, S2, S3, S4, S5, S6, S7 = *model.SPR_jt[j,t]
                                ^
SyntaxError: can't use starred expression here

C:\Users\pu>python C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py
>>Using the solver bonmin running in C:\Users\pu\Pictures\MINLP-Solve\minlp\..\solvers\CoinAll-1.6.0-win64-intel11.1\bin\bonmin.exe
>>Parsing .xlsx file in C:\Users\pu\Pictures\MINLP-Solve\minlp\Parameters.xlsx
>>Loaded index values:
t = [1, 2, 3, 4, 5, 6, 7]
f = [1, 2]
w = [1, 2, 3]
r = [1, 2, 3, 4]
i = [1, 2, 3]
k = [4, 5, 6, 7]
j = [1, 2, 3, 4, 5, 6, 7]
>>Loaded parameter values:
model.M = 10000000.0
model.LE1 = 0.999
model.SPR_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.VC_if = [5.0, 5.0, 6.0, 6.0, 4.0, 4.0]
model.FC_if = [5000.0, 6000.0, 3000.0, 3500.0, 2000.0, 2500.0]
model.ICF_jf = [0.15, 0.15, 0.2, 0.2, 0.25, 0.25, 0.35, 0.35, 0.4, 0.4, 0.45, 0.45, 0.6, 0.6]
model.ICW_jw = [0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.3, 0.3, 0.3, 0.45, 0.45, 0.45, 0.5, 0.5, 0.5, 0.55, 0.55, 0.55, 0.75, 0.75, 0.75]
model.TCFW_jfw = [0.5, 0.5, 0.7, 0.7, 0.5, 0.5, 0.55, 0.55, 0.75, 0.75, 0.55, 0.55, 0.45, 0.45, 0.65, 0.65, 0.45, 0.45, 1.05, 1.05, 1.45, 1.45, 1.05, 1.05, 0.95, 0.95, 1.35, 1.35, 0.95, 0.95, 1.0, 1.0, 1.4, 1.4, 1.0, 1.0, 1.5, 1.5, 2.1, 2.1, 1.5, 1.5]
model.TCFR_jfr = [0.9, 0.9, 1.1, 1.2, 1.2, 1.1, 0.9, 0.9, 0.95, 0.95, 1.15, 1.25, 1.25, 1.15, 0.95, 0.95, 0.85, 0.85, 1.05, 1.15, 1.15, 1.05, 0.85, 0.85, 1.85, 1.85, 2.25, 2.45, 2.45, 2.25, 1.85, 1.85, 1.75, 1.75, 2.15, 2.35, 2.35, 2.15, 1.75, 1.75, 1.8, 1.8, 2.2, 2.4, 2.4, 2.2, 1.8, 1.8, 2.7, 2.7, 3.3, 3.6, 3.6, 3.3, 2.7, 2.7]
model.TCWR_jwr = [0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.15, 0.15, 0.25, 0.35, 0.35, 0.15, 0.15, 0.25, 0.35, 0.25, 0.15, 0.15, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.35, 0.35, 0.55, 0.75, 0.65, 0.35, 0.35, 0.55, 0.75, 0.55, 0.35, 0.35, 0.4, 0.4, 0.6, 0.8, 0.7, 0.4, 0.4, 0.6, 0.8, 0.6, 0.4, 0.4, 0.6, 0.6, 0.9, 1.2, 1.0, 0.6, 0.6, 0.9, 1.2, 0.9, 0.6, 0.6]
model.BOC_r = [3.5, 3.5, 3.5, 3.5]
model.INTCOSTW_kw = [5000.0, 5000.0, 5000.0, 4000.0, 4000.0, 4000.0, 4500.0, 4500.0, 4500.0, 5200.0, 5200.0, 5200.0]
model.INTCOSTF_kf = [3000.0, 3000.0, 2000.0, 2000.0, 2500.0, 2500.0, 3200.0, 3200.0]
model.SETCOSTW_kw = [500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0]
model.SETCOSTF_kf = [300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0]
model.BCW_kw = [1.8, 1.8, 1.8, 1.5, 1.5, 1.5, 2.5, 2.5, 2.5, 1.8, 1.8, 1.8]
model.BCF_kf = [1.5, 1.5, 1.0, 1.0, 2.0, 2.0, 1.5, 1.5]
model.PCAP_if = [5000.0, 5000.0, 5500.0, 5500.0, 4500.0, 4500.0]
model.ICAP_f = [7000.0, 7000.0]
model.WCAP_w = [14000.0, 14000.0, 14000.0]
model.BCAPW_kw = [2800.0, 2800.0, 2800.0, 2300.0, 2300.0, 2300.0, 2550.0, 2550.0, 2550.0, 2100.0, 2100.0, 2100.0]
model.BCAPF_kf = [3000.0, 3000.0, 2500.0, 2500.0, 2750.0, 2750.0, 2300.0, 2300.0]
model.INITIALINVF_if = [850.0, 800.0, 700.0, 600.0, 500.0, 300.0]
model.INITIALINVW_iw = [1000.0, 1100.0, 950.0, 800.0, 900.0, 850.0, 700.0, 800.0, 750.0]
model.ST_j = [1.0, 1.0, 1.0, 1.5, 1.5, 1.5, 2.0]
model.x_fw = [1.0, 1.0, 2.0, 2.0, 1.0, 1.0]
model.x_fr = [1.0, 1.0, 1.0, 2.0, 2.0, 1.0, 1.0, 1.0]
model.x_wr = [1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0]
model.x_r = [2.0, 2.0, 2.0, 2.0]
model.Y_ij = [1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0]
model.MARKUP = 0.05
model.RPMean_i = [15.0, 17.0, 13.0]
model.RPStdDev_i = [1.0, 2.0, 0.5]
model.Correlation_iI = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
model.Covariance_iI = [1.0, 0.0, 0.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.25]
model.Lambda_rt = [1000.0, 900.0, 950.0, 1100.0, 1200.0, 1300.0, 1300.0, 1300.0, 1200.0, 1250.0, 1400.0, 1500.0, 1600.0, 1600.0, 1100.0, 1000.0, 1050.0, 1200.0, 1300.0, 1400.0, 1400.0, 1200.0, 1100.0, 1150.0, 1300.0, 1400.0, 1500.0, 1500.0]
model.Contingency_k = [0.0, 0.0, 0.0, 0.0]
model.SP_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.alpha_jt = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.56, 0.14, 0.56, 0.14, 0.56, 0.14, 0.56, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.3, 0.0, 0.3, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.56, 0.22, 0.56, 0.22, 0.56, 0.22]
Traceback (most recent call last):
  File "C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py", line 80, in <module>
    S1, S2, S3, S4, S5, S6, S7 = model.SPR_jt[j,t]
NameError: name 'j' is not defined

C:\Users\pu>python C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py
>>Using the solver bonmin running in C:\Users\pu\Pictures\MINLP-Solve\minlp\..\solvers\CoinAll-1.6.0-win64-intel11.1\bin\bonmin.exe
>>Parsing .xlsx file in C:\Users\pu\Pictures\MINLP-Solve\minlp\Parameters.xlsx
>>Loaded index values:
t = [1, 2, 3, 4, 5, 6, 7]
f = [1, 2]
w = [1, 2, 3]
r = [1, 2, 3, 4]
i = [1, 2, 3]
k = [4, 5, 6, 7]
j = [1, 2, 3, 4, 5, 6, 7]
>>Loaded parameter values:
model.M = 10000000.0
model.LE1 = 0.999
model.SPR_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.VC_if = [5.0, 5.0, 6.0, 6.0, 4.0, 4.0]
model.FC_if = [5000.0, 6000.0, 3000.0, 3500.0, 2000.0, 2500.0]
model.ICF_jf = [0.15, 0.15, 0.2, 0.2, 0.25, 0.25, 0.35, 0.35, 0.4, 0.4, 0.45, 0.45, 0.6, 0.6]
model.ICW_jw = [0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.3, 0.3, 0.3, 0.45, 0.45, 0.45, 0.5, 0.5, 0.5, 0.55, 0.55, 0.55, 0.75, 0.75, 0.75]
model.TCFW_jfw = [0.5, 0.5, 0.7, 0.7, 0.5, 0.5, 0.55, 0.55, 0.75, 0.75, 0.55, 0.55, 0.45, 0.45, 0.65, 0.65, 0.45, 0.45, 1.05, 1.05, 1.45, 1.45, 1.05, 1.05, 0.95, 0.95, 1.35, 1.35, 0.95, 0.95, 1.0, 1.0, 1.4, 1.4, 1.0, 1.0, 1.5, 1.5, 2.1, 2.1, 1.5, 1.5]
model.TCFR_jfr = [0.9, 0.9, 1.1, 1.2, 1.2, 1.1, 0.9, 0.9, 0.95, 0.95, 1.15, 1.25, 1.25, 1.15, 0.95, 0.95, 0.85, 0.85, 1.05, 1.15, 1.15, 1.05, 0.85, 0.85, 1.85, 1.85, 2.25, 2.45, 2.45, 2.25, 1.85, 1.85, 1.75, 1.75, 2.15, 2.35, 2.35, 2.15, 1.75, 1.75, 1.8, 1.8, 2.2, 2.4, 2.4, 2.2, 1.8, 1.8, 2.7, 2.7, 3.3, 3.6, 3.6, 3.3, 2.7, 2.7]
model.TCWR_jwr = [0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.15, 0.15, 0.25, 0.35, 0.35, 0.15, 0.15, 0.25, 0.35, 0.25, 0.15, 0.15, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.35, 0.35, 0.55, 0.75, 0.65, 0.35, 0.35, 0.55, 0.75, 0.55, 0.35, 0.35, 0.4, 0.4, 0.6, 0.8, 0.7, 0.4, 0.4, 0.6, 0.8, 0.6, 0.4, 0.4, 0.6, 0.6, 0.9, 1.2, 1.0, 0.6, 0.6, 0.9, 1.2, 0.9, 0.6, 0.6]
model.BOC_r = [3.5, 3.5, 3.5, 3.5]
model.INTCOSTW_kw = [5000.0, 5000.0, 5000.0, 4000.0, 4000.0, 4000.0, 4500.0, 4500.0, 4500.0, 5200.0, 5200.0, 5200.0]
model.INTCOSTF_kf = [3000.0, 3000.0, 2000.0, 2000.0, 2500.0, 2500.0, 3200.0, 3200.0]
model.SETCOSTW_kw = [500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0]
model.SETCOSTF_kf = [300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0]
model.BCW_kw = [1.8, 1.8, 1.8, 1.5, 1.5, 1.5, 2.5, 2.5, 2.5, 1.8, 1.8, 1.8]
model.BCF_kf = [1.5, 1.5, 1.0, 1.0, 2.0, 2.0, 1.5, 1.5]
model.PCAP_if = [5000.0, 5000.0, 5500.0, 5500.0, 4500.0, 4500.0]
model.ICAP_f = [7000.0, 7000.0]
model.WCAP_w = [14000.0, 14000.0, 14000.0]
model.BCAPW_kw = [2800.0, 2800.0, 2800.0, 2300.0, 2300.0, 2300.0, 2550.0, 2550.0, 2550.0, 2100.0, 2100.0, 2100.0]
model.BCAPF_kf = [3000.0, 3000.0, 2500.0, 2500.0, 2750.0, 2750.0, 2300.0, 2300.0]
model.INITIALINVF_if = [850.0, 800.0, 700.0, 600.0, 500.0, 300.0]
model.INITIALINVW_iw = [1000.0, 1100.0, 950.0, 800.0, 900.0, 850.0, 700.0, 800.0, 750.0]
model.ST_j = [1.0, 1.0, 1.0, 1.5, 1.5, 1.5, 2.0]
model.x_fw = [1.0, 1.0, 2.0, 2.0, 1.0, 1.0]
model.x_fr = [1.0, 1.0, 1.0, 2.0, 2.0, 1.0, 1.0, 1.0]
model.x_wr = [1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0]
model.x_r = [2.0, 2.0, 2.0, 2.0]
model.Y_ij = [1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0]
model.MARKUP = 0.05
model.RPMean_i = [15.0, 17.0, 13.0]
model.RPStdDev_i = [1.0, 2.0, 0.5]
model.Correlation_iI = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
model.Covariance_iI = [1.0, 0.0, 0.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.25]
model.Lambda_rt = [1000.0, 900.0, 950.0, 1100.0, 1200.0, 1300.0, 1300.0, 1300.0, 1200.0, 1250.0, 1400.0, 1500.0, 1600.0, 1600.0, 1100.0, 1000.0, 1050.0, 1200.0, 1300.0, 1400.0, 1400.0, 1200.0, 1100.0, 1150.0, 1300.0, 1400.0, 1500.0, 1500.0]
model.Contingency_k = [0.0, 0.0, 0.0, 0.0]
model.SP_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.alpha_jt = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.56, 0.14, 0.56, 0.14, 0.56, 0.14, 0.56, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.3, 0.0, 0.3, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.56, 0.22, 0.56, 0.22, 0.56, 0.22]
>>Running script =====
 ("ALPHA [0,1] COMPUTATION")
SPR = 14.0;
B = Min[ 16.0, 30.0/(1+0.0) - x ];
A = Min[ 12.0, 26.0/(1+0.0) - x, 28.0/(1+0.0) - y, 42.0/(1+0.0) - x - y ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, -intlimit, SPR}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.0011136440193612695] | Time elapsed (sec): 8.796503067016602
>>Running script =====
 ("ALPHA [1,1] COMPUTATION")
SPR = 14.0;
B = Min[ x - 14.0 + 16.0, (x-14.0+30.0)/(1+0.0) - x ];
A = Min[ x - 14.0 + 12.0, (x-14.0+26.0)/(1+0.0) - x, (x-14.0+28.0)/(1+0.0) - y, (x-14.0+42.0)/(1+0.0) - x - y ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, SPR, intlimit}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.005905625697621384] | Time elapsed (sec): 8.791502952575684
Traceback (most recent call last):
  File "C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py", line 147, in <module>
    math_output = RunMathematica(alphaX_query_replace, alphaX_query)
NameError: name 'alphaX_query_replace' is not defined

C:\Users\pu>python C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py
>>Using the solver bonmin running in C:\Users\pu\Pictures\MINLP-Solve\minlp\..\solvers\CoinAll-1.6.0-win64-intel11.1\bin\bonmin.exe
>>Parsing .xlsx file in C:\Users\pu\Pictures\MINLP-Solve\minlp\Parameters.xlsx
>>Loaded index values:
t = [1, 2, 3, 4, 5, 6, 7]
f = [1, 2]
w = [1, 2, 3]
r = [1, 2, 3, 4]
i = [1, 2, 3]
k = [4, 5, 6, 7]
j = [1, 2, 3, 4, 5, 6, 7]
>>Loaded parameter values:
model.M = 10000000.0
model.LE1 = 0.999
model.SPR_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.VC_if = [5.0, 5.0, 6.0, 6.0, 4.0, 4.0]
model.FC_if = [5000.0, 6000.0, 3000.0, 3500.0, 2000.0, 2500.0]
model.ICF_jf = [0.15, 0.15, 0.2, 0.2, 0.25, 0.25, 0.35, 0.35, 0.4, 0.4, 0.45, 0.45, 0.6, 0.6]
model.ICW_jw = [0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.3, 0.3, 0.3, 0.45, 0.45, 0.45, 0.5, 0.5, 0.5, 0.55, 0.55, 0.55, 0.75, 0.75, 0.75]
model.TCFW_jfw = [0.5, 0.5, 0.7, 0.7, 0.5, 0.5, 0.55, 0.55, 0.75, 0.75, 0.55, 0.55, 0.45, 0.45, 0.65, 0.65, 0.45, 0.45, 1.05, 1.05, 1.45, 1.45, 1.05, 1.05, 0.95, 0.95, 1.35, 1.35, 0.95, 0.95, 1.0, 1.0, 1.4, 1.4, 1.0, 1.0, 1.5, 1.5, 2.1, 2.1, 1.5, 1.5]
model.TCFR_jfr = [0.9, 0.9, 1.1, 1.2, 1.2, 1.1, 0.9, 0.9, 0.95, 0.95, 1.15, 1.25, 1.25, 1.15, 0.95, 0.95, 0.85, 0.85, 1.05, 1.15, 1.15, 1.05, 0.85, 0.85, 1.85, 1.85, 2.25, 2.45, 2.45, 2.25, 1.85, 1.85, 1.75, 1.75, 2.15, 2.35, 2.35, 2.15, 1.75, 1.75, 1.8, 1.8, 2.2, 2.4, 2.4, 2.2, 1.8, 1.8, 2.7, 2.7, 3.3, 3.6, 3.6, 3.3, 2.7, 2.7]
model.TCWR_jwr = [0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.15, 0.15, 0.25, 0.35, 0.35, 0.15, 0.15, 0.25, 0.35, 0.25, 0.15, 0.15, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.35, 0.35, 0.55, 0.75, 0.65, 0.35, 0.35, 0.55, 0.75, 0.55, 0.35, 0.35, 0.4, 0.4, 0.6, 0.8, 0.7, 0.4, 0.4, 0.6, 0.8, 0.6, 0.4, 0.4, 0.6, 0.6, 0.9, 1.2, 1.0, 0.6, 0.6, 0.9, 1.2, 0.9, 0.6, 0.6]
model.BOC_r = [3.5, 3.5, 3.5, 3.5]
model.INTCOSTW_kw = [5000.0, 5000.0, 5000.0, 4000.0, 4000.0, 4000.0, 4500.0, 4500.0, 4500.0, 5200.0, 5200.0, 5200.0]
model.INTCOSTF_kf = [3000.0, 3000.0, 2000.0, 2000.0, 2500.0, 2500.0, 3200.0, 3200.0]
model.SETCOSTW_kw = [500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0]
model.SETCOSTF_kf = [300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0]
model.BCW_kw = [1.8, 1.8, 1.8, 1.5, 1.5, 1.5, 2.5, 2.5, 2.5, 1.8, 1.8, 1.8]
model.BCF_kf = [1.5, 1.5, 1.0, 1.0, 2.0, 2.0, 1.5, 1.5]
model.PCAP_if = [5000.0, 5000.0, 5500.0, 5500.0, 4500.0, 4500.0]
model.ICAP_f = [7000.0, 7000.0]
model.WCAP_w = [14000.0, 14000.0, 14000.0]
model.BCAPW_kw = [2800.0, 2800.0, 2800.0, 2300.0, 2300.0, 2300.0, 2550.0, 2550.0, 2550.0, 2100.0, 2100.0, 2100.0]
model.BCAPF_kf = [3000.0, 3000.0, 2500.0, 2500.0, 2750.0, 2750.0, 2300.0, 2300.0]
model.INITIALINVF_if = [850.0, 800.0, 700.0, 600.0, 500.0, 300.0]
model.INITIALINVW_iw = [1000.0, 1100.0, 950.0, 800.0, 900.0, 850.0, 700.0, 800.0, 750.0]
model.ST_j = [1.0, 1.0, 1.0, 1.5, 1.5, 1.5, 2.0]
model.x_fw = [1.0, 1.0, 2.0, 2.0, 1.0, 1.0]
model.x_fr = [1.0, 1.0, 1.0, 2.0, 2.0, 1.0, 1.0, 1.0]
model.x_wr = [1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0]
model.x_r = [2.0, 2.0, 2.0, 2.0]
model.Y_ij = [1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0]
model.MARKUP = 0.05
model.RPMean_i = [15.0, 17.0, 13.0]
model.RPStdDev_i = [1.0, 2.0, 0.5]
model.Correlation_iI = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
model.Covariance_iI = [1.0, 0.0, 0.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.25]
model.Lambda_rt = [1000.0, 900.0, 950.0, 1100.0, 1200.0, 1300.0, 1300.0, 1300.0, 1200.0, 1250.0, 1400.0, 1500.0, 1600.0, 1600.0, 1100.0, 1000.0, 1050.0, 1200.0, 1300.0, 1400.0, 1400.0, 1200.0, 1100.0, 1150.0, 1300.0, 1400.0, 1500.0, 1500.0]
model.Contingency_k = [0.0, 0.0, 0.0, 0.0]
model.SP_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.alpha_jt = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.56, 0.14, 0.56, 0.14, 0.56, 0.14, 0.56, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.3, 0.0, 0.3, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.56, 0.22, 0.56, 0.22, 0.56, 0.22]
>>Running script =====
 ("ALPHA [0,1] COMPUTATION")
SPR = 14.0;
B = Min[ 16.0, 30.0/(1+0.0) - x ];
A = Min[ 12.0, 26.0/(1+0.0) - x, 28.0/(1+0.0) - y, 42.0/(1+0.0) - x - y ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, -intlimit, SPR}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.0011136440193612695] | Time elapsed (sec): 8.582490921020508
>>Running script =====
 ("ALPHA [1,1] COMPUTATION")
SPR = 14.0;
B = Min[ x - 14.0 + 16.0, (x-14.0+30.0)/(1+0.0) - x ];
A = Min[ x - 14.0 + 12.0, (x-14.0+26.0)/(1+0.0) - x, (x-14.0+28.0)/(1+0.0) - y, (x-14.0+42.0)/(1+0.0) - x - y ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, SPR, intlimit}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.005905625697621384] | Time elapsed (sec): 8.82950496673584
Traceback (most recent call last):
  File "C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py", line 147, in <module>
    math_output = RunMathematica(alpha2_query_replace, alpha2_query)
  File "C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py", line 53, in RunMathematica
    run_script = dict_replace(query, values)
  File "C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py", line 47, in dict_replace
    for key, value in dict.items():
AttributeError: 'str' object has no attribute 'items'

C:\Users\pu>python C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py
>>Using the solver bonmin running in C:\Users\pu\Pictures\MINLP-Solve\minlp\..\solvers\CoinAll-1.6.0-win64-intel11.1\bin\bonmin.exe
>>Parsing .xlsx file in C:\Users\pu\Pictures\MINLP-Solve\minlp\Parameters.xlsx
>>Loaded index values:
t = [1, 2, 3, 4, 5, 6, 7]
f = [1, 2]
w = [1, 2, 3]
r = [1, 2, 3, 4]
i = [1, 2, 3]
k = [4, 5, 6, 7]
j = [1, 2, 3, 4, 5, 6, 7]
>>Loaded parameter values:
model.M = 10000000.0
model.LE1 = 0.999
model.SPR_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.VC_if = [5.0, 5.0, 6.0, 6.0, 4.0, 4.0]
model.FC_if = [5000.0, 6000.0, 3000.0, 3500.0, 2000.0, 2500.0]
model.ICF_jf = [0.15, 0.15, 0.2, 0.2, 0.25, 0.25, 0.35, 0.35, 0.4, 0.4, 0.45, 0.45, 0.6, 0.6]
model.ICW_jw = [0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.3, 0.3, 0.3, 0.45, 0.45, 0.45, 0.5, 0.5, 0.5, 0.55, 0.55, 0.55, 0.75, 0.75, 0.75]
model.TCFW_jfw = [0.5, 0.5, 0.7, 0.7, 0.5, 0.5, 0.55, 0.55, 0.75, 0.75, 0.55, 0.55, 0.45, 0.45, 0.65, 0.65, 0.45, 0.45, 1.05, 1.05, 1.45, 1.45, 1.05, 1.05, 0.95, 0.95, 1.35, 1.35, 0.95, 0.95, 1.0, 1.0, 1.4, 1.4, 1.0, 1.0, 1.5, 1.5, 2.1, 2.1, 1.5, 1.5]
model.TCFR_jfr = [0.9, 0.9, 1.1, 1.2, 1.2, 1.1, 0.9, 0.9, 0.95, 0.95, 1.15, 1.25, 1.25, 1.15, 0.95, 0.95, 0.85, 0.85, 1.05, 1.15, 1.15, 1.05, 0.85, 0.85, 1.85, 1.85, 2.25, 2.45, 2.45, 2.25, 1.85, 1.85, 1.75, 1.75, 2.15, 2.35, 2.35, 2.15, 1.75, 1.75, 1.8, 1.8, 2.2, 2.4, 2.4, 2.2, 1.8, 1.8, 2.7, 2.7, 3.3, 3.6, 3.6, 3.3, 2.7, 2.7]
model.TCWR_jwr = [0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.15, 0.15, 0.25, 0.35, 0.35, 0.15, 0.15, 0.25, 0.35, 0.25, 0.15, 0.15, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.35, 0.35, 0.55, 0.75, 0.65, 0.35, 0.35, 0.55, 0.75, 0.55, 0.35, 0.35, 0.4, 0.4, 0.6, 0.8, 0.7, 0.4, 0.4, 0.6, 0.8, 0.6, 0.4, 0.4, 0.6, 0.6, 0.9, 1.2, 1.0, 0.6, 0.6, 0.9, 1.2, 0.9, 0.6, 0.6]
model.BOC_r = [3.5, 3.5, 3.5, 3.5]
model.INTCOSTW_kw = [5000.0, 5000.0, 5000.0, 4000.0, 4000.0, 4000.0, 4500.0, 4500.0, 4500.0, 5200.0, 5200.0, 5200.0]
model.INTCOSTF_kf = [3000.0, 3000.0, 2000.0, 2000.0, 2500.0, 2500.0, 3200.0, 3200.0]
model.SETCOSTW_kw = [500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0]
model.SETCOSTF_kf = [300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0]
model.BCW_kw = [1.8, 1.8, 1.8, 1.5, 1.5, 1.5, 2.5, 2.5, 2.5, 1.8, 1.8, 1.8]
model.BCF_kf = [1.5, 1.5, 1.0, 1.0, 2.0, 2.0, 1.5, 1.5]
model.PCAP_if = [5000.0, 5000.0, 5500.0, 5500.0, 4500.0, 4500.0]
model.ICAP_f = [7000.0, 7000.0]
model.WCAP_w = [14000.0, 14000.0, 14000.0]
model.BCAPW_kw = [2800.0, 2800.0, 2800.0, 2300.0, 2300.0, 2300.0, 2550.0, 2550.0, 2550.0, 2100.0, 2100.0, 2100.0]
model.BCAPF_kf = [3000.0, 3000.0, 2500.0, 2500.0, 2750.0, 2750.0, 2300.0, 2300.0]
model.INITIALINVF_if = [850.0, 800.0, 700.0, 600.0, 500.0, 300.0]
model.INITIALINVW_iw = [1000.0, 1100.0, 950.0, 800.0, 900.0, 850.0, 700.0, 800.0, 750.0]
model.ST_j = [1.0, 1.0, 1.0, 1.5, 1.5, 1.5, 2.0]
model.x_fw = [1.0, 1.0, 2.0, 2.0, 1.0, 1.0]
model.x_fr = [1.0, 1.0, 1.0, 2.0, 2.0, 1.0, 1.0, 1.0]
model.x_wr = [1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0]
model.x_r = [2.0, 2.0, 2.0, 2.0]
model.Y_ij = [1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0]
model.MARKUP = 0.05
model.RPMean_i = [15.0, 17.0, 13.0]
model.RPStdDev_i = [1.0, 2.0, 0.5]
model.Correlation_iI = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
model.Covariance_iI = [1.0, 0.0, 0.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.25]
model.Lambda_rt = [1000.0, 900.0, 950.0, 1100.0, 1200.0, 1300.0, 1300.0, 1300.0, 1200.0, 1250.0, 1400.0, 1500.0, 1600.0, 1600.0, 1100.0, 1000.0, 1050.0, 1200.0, 1300.0, 1400.0, 1400.0, 1200.0, 1100.0, 1150.0, 1300.0, 1400.0, 1500.0, 1500.0]
model.Contingency_k = [0.0, 0.0, 0.0, 0.0]
model.SP_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.alpha_jt = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.56, 0.14, 0.56, 0.14, 0.56, 0.14, 0.56, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.3, 0.0, 0.3, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.56, 0.22, 0.56, 0.22, 0.56, 0.22]
>>Running script =====
 ("ALPHA [0,1] COMPUTATION")
SPR = 14.0;
B = Min[ 16.0, 30.0/(1+0.0) - x ];
A = Min[ 12.0, 26.0/(1+0.0) - x, 28.0/(1+0.0) - y, 42.0/(1+0.0) - x - y ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, -intlimit, SPR}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.0011136440193612695] | Time elapsed (sec): 8.749500274658203
>>Running script =====
 ("ALPHA [1,1] COMPUTATION")
SPR = 14.0;
B = Min[ x - 14.0 + 16.0, (x-14.0+30.0)/(1+0.0) - x ];
A = Min[ x - 14.0 + 12.0, (x-14.0+26.0)/(1+0.0) - x, (x-14.0+28.0)/(1+0.0) - y, (x-14.0+42.0)/(1+0.0) - x - y ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, SPR, intlimit}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.005905625697621384] | Time elapsed (sec): 8.752500534057617
>>Running script =====
 ("ALPHA [2,1] COMPUTATION")
SPR = 16.0;
B = Min[ x - 16.0 + 14.0, (x-16.0+30.0)/(1+0.0) - x ];
A = Min[ x - 16.0 + 12.0, (x-16.0+26.0)/(1+0.0) - y, (x-16.0+28.0)/(1+0.0) - x, (x-16.0+42.0)/(1+42.0) - y - x ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, SPR, intlimit}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: ["b'-0.034364156741983926 + Integrate[(0.00453799475942005*Erfc[0.024666515622786545*(407. + 14.*x)])/E^(0.5*(-15. + x)^2), {x, 16., Infinity}]\\r\\n'"] | Time elapsed (sec): 169.22867941856384
Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 18:41:36) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>>
KeyboardInterrupt
>>> exit()

C:\Users\pu>python C:\Users\pu\Pictures\MINLP-Solve\minlp\solver.py
>>Using the solver bonmin running in C:\Users\pu\Pictures\MINLP-Solve\minlp\..\solvers\CoinAll-1.6.0-win64-intel11.1\bin\bonmin.exe
>>Parsing .xlsx file in C:\Users\pu\Pictures\MINLP-Solve\minlp\Parameters.xlsx
>>Loaded index values:
t = [1, 2, 3, 4, 5, 6, 7]
f = [1, 2]
w = [1, 2, 3]
r = [1, 2, 3, 4]
i = [1, 2, 3]
k = [4, 5, 6, 7]
j = [1, 2, 3, 4, 5, 6, 7]
>>Loaded parameter values:
model.M = 10000000.0
model.LE1 = 0.999
model.SPR_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.VC_if = [5.0, 5.0, 6.0, 6.0, 4.0, 4.0]
model.FC_if = [5000.0, 6000.0, 3000.0, 3500.0, 2000.0, 2500.0]
model.ICF_jf = [0.15, 0.15, 0.2, 0.2, 0.25, 0.25, 0.35, 0.35, 0.4, 0.4, 0.45, 0.45, 0.6, 0.6]
model.ICW_jw = [0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.3, 0.3, 0.3, 0.45, 0.45, 0.45, 0.5, 0.5, 0.5, 0.55, 0.55, 0.55, 0.75, 0.75, 0.75]
model.TCFW_jfw = [0.5, 0.5, 0.7, 0.7, 0.5, 0.5, 0.55, 0.55, 0.75, 0.75, 0.55, 0.55, 0.45, 0.45, 0.65, 0.65, 0.45, 0.45, 1.05, 1.05, 1.45, 1.45, 1.05, 1.05, 0.95, 0.95, 1.35, 1.35, 0.95, 0.95, 1.0, 1.0, 1.4, 1.4, 1.0, 1.0, 1.5, 1.5, 2.1, 2.1, 1.5, 1.5]
model.TCFR_jfr = [0.9, 0.9, 1.1, 1.2, 1.2, 1.1, 0.9, 0.9, 0.95, 0.95, 1.15, 1.25, 1.25, 1.15, 0.95, 0.95, 0.85, 0.85, 1.05, 1.15, 1.15, 1.05, 0.85, 0.85, 1.85, 1.85, 2.25, 2.45, 2.45, 2.25, 1.85, 1.85, 1.75, 1.75, 2.15, 2.35, 2.35, 2.15, 1.75, 1.75, 1.8, 1.8, 2.2, 2.4, 2.4, 2.2, 1.8, 1.8, 2.7, 2.7, 3.3, 3.6, 3.6, 3.3, 2.7, 2.7]
model.TCWR_jwr = [0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.3, 0.4, 0.3, 0.2, 0.2, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.35, 0.45, 0.35, 0.25, 0.25, 0.15, 0.15, 0.25, 0.35, 0.35, 0.15, 0.15, 0.25, 0.35, 0.25, 0.15, 0.15, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.65, 0.85, 0.65, 0.45, 0.45, 0.35, 0.35, 0.55, 0.75, 0.65, 0.35, 0.35, 0.55, 0.75, 0.55, 0.35, 0.35, 0.4, 0.4, 0.6, 0.8, 0.7, 0.4, 0.4, 0.6, 0.8, 0.6, 0.4, 0.4, 0.6, 0.6, 0.9, 1.2, 1.0, 0.6, 0.6, 0.9, 1.2, 0.9, 0.6, 0.6]
model.BOC_r = [3.5, 3.5, 3.5, 3.5]
model.INTCOSTW_kw = [5000.0, 5000.0, 5000.0, 4000.0, 4000.0, 4000.0, 4500.0, 4500.0, 4500.0, 5200.0, 5200.0, 5200.0]
model.INTCOSTF_kf = [3000.0, 3000.0, 2000.0, 2000.0, 2500.0, 2500.0, 3200.0, 3200.0]
model.SETCOSTW_kw = [500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0, 500.0]
model.SETCOSTF_kf = [300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0]
model.BCW_kw = [1.8, 1.8, 1.8, 1.5, 1.5, 1.5, 2.5, 2.5, 2.5, 1.8, 1.8, 1.8]
model.BCF_kf = [1.5, 1.5, 1.0, 1.0, 2.0, 2.0, 1.5, 1.5]
model.PCAP_if = [5000.0, 5000.0, 5500.0, 5500.0, 4500.0, 4500.0]
model.ICAP_f = [7000.0, 7000.0]
model.WCAP_w = [14000.0, 14000.0, 14000.0]
model.BCAPW_kw = [2800.0, 2800.0, 2800.0, 2300.0, 2300.0, 2300.0, 2550.0, 2550.0, 2550.0, 2100.0, 2100.0, 2100.0]
model.BCAPF_kf = [3000.0, 3000.0, 2500.0, 2500.0, 2750.0, 2750.0, 2300.0, 2300.0]
model.INITIALINVF_if = [850.0, 800.0, 700.0, 600.0, 500.0, 300.0]
model.INITIALINVW_iw = [1000.0, 1100.0, 950.0, 800.0, 900.0, 850.0, 700.0, 800.0, 750.0]
model.ST_j = [1.0, 1.0, 1.0, 1.5, 1.5, 1.5, 2.0]
model.x_fw = [1.0, 1.0, 2.0, 2.0, 1.0, 1.0]
model.x_fr = [1.0, 1.0, 1.0, 2.0, 2.0, 1.0, 1.0, 1.0]
model.x_wr = [1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0]
model.x_r = [2.0, 2.0, 2.0, 2.0]
model.Y_ij = [1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0]
model.MARKUP = 0.05
model.RPMean_i = [15.0, 17.0, 13.0]
model.RPStdDev_i = [1.0, 2.0, 0.5]
model.Correlation_iI = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
model.Covariance_iI = [1.0, 0.0, 0.0, 0.0, 4.0, 0.0, 0.0, 0.0, 0.25]
model.Lambda_rt = [1000.0, 900.0, 950.0, 1100.0, 1200.0, 1300.0, 1300.0, 1300.0, 1200.0, 1250.0, 1400.0, 1500.0, 1600.0, 1600.0, 1100.0, 1000.0, 1050.0, 1200.0, 1300.0, 1400.0, 1400.0, 1200.0, 1100.0, 1150.0, 1300.0, 1400.0, 1500.0, 1500.0]
model.Contingency_k = [0.0, 0.0, 0.0, 0.0]
model.SP_jt = [14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 14.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 26.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 28.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0]
model.alpha_jt = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.56, 0.14, 0.56, 0.14, 0.56, 0.14, 0.56, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.22, 0.0, 0.3, 0.0, 0.3, 0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.22, 0.56, 0.22, 0.56, 0.22, 0.56, 0.22]
>>Running script =====
 ("ALPHA [0,1] COMPUTATION")
SPR = 14.0;
B = Min[ 16.0, 30.0/(1+0.0) - x ];
A = Min[ 12.0, 26.0/(1+0.0) - x, 28.0/(1+0.0) - y, 42.0/(1+0.0) - x - y ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, -intlimit, SPR}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.0011136440193612695] | Time elapsed (sec): 8.667495727539062
>>Running script =====
 ("ALPHA [1,1] COMPUTATION")
SPR = 14.0;
B = Min[ x - 14.0 + 16.0, (x-14.0+30.0)/(1+0.0) - x ];
A = Min[ x - 14.0 + 12.0, (x-14.0+26.0)/(1+0.0) - x, (x-14.0+28.0)/(1+0.0) - y, (x-14.0+42.0)/(1+0.0) - x - y ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, SPR, intlimit}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.005905625697621384] | Time elapsed (sec): 8.82350468635559
>>Running script =====
 ("ALPHA [2,1] COMPUTATION")
SPR = 16.0;
B = Min[ x - 16.0 + 14.0, (x-16.0+30.0)/(1+0.0) - x ];
A = Min[ x - 16.0 + 12.0, (x-16.0+26.0)/(1+0.0) - y, (x-16.0+28.0)/(1+0.0) - x, (x-16.0+42.0)/(1+0.0) - y - x ];
mu = { { 15.0, 17.0, 13.0 } };
sig = { { 1.0, 0.0, 0.0 }, { 0.0, 4.0, 0.0 }, { 0.0, 0.0, 0.25 } };
h = 3;
r = { {x, y, z} };
intlimit = Infinity;
mulres = ((r - mu).Inverse[sig].Transpose[r - mu])[[1,1]];
f = Exp[-1/2 * mulres]/Sqrt[(2*Pi)^h * Det[sig]];
intres = Integrate[f, {x, SPR, intlimit}, {y, -intlimit, B}, {z, -intlimit, A}];
Print[intres]; (" OUTPUT # 1 ")

<<End of script ======
>>Returned: [0.00024113578027016924] | Time elapsed (sec): 8.79550313949585
Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 18:41:36) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> exit()

C:\Users\pu>C:\Users\pu\Pictures\MINLP-Solve\solvers\CoinAll-1.6.0-win64-intel11.1\bin\couenne.exe -=
Couenne 0.4.0 --  an Open-Source solver for Mixed Integer Nonlinear Optimization
Mailing list: couenne@list.coin-or.org
Instructions: http://www.coin-or.org/Couenne
acceptable_compl_inf_tol                       Acceptance threshold for the complementarity conditions
acceptable_constr_viol_tol                     Acceptance threshold for the constraint violation
acceptable_dual_inf_tol                        Acceptance threshold for the dual infeasibility
acceptable_tol                                 Acceptable convergence tolerance (relative)
alpha_for_y                                    Step size for constraint multipliers
bonmin.add_only_violated_oa                    Do we add all OA cuts or only the ones violated by current point?
bonmin.aggressive_fbbt                         Aggressive feasibility-based bound tightening (to use with NLP points)
bonmin.algorithm                               Choice of the algorithm.
bonmin.allowable_fraction_gap                  Specify the value of relative gap under which the algorithm stops.
bonmin.allowable_gap                           Specify the value of absolute gap under which the algorithm stops.
bonmin.art_cutoff                              Artificial cutoff
bonmin.art_lower                               Artificial lower bound
bonmin.bb_log_interval                         Interval at which node level output is printed.
bonmin.bb_log_level                            specify main branch-and-bound log level.
bonmin.branching_object                        type of branching object for variable selection
bonmin.candidate_sort_criterion                Choice of the criterion to choose candidates in strong-branching
bonmin.coeff_var_threshold                     Coefficient of variation threshold (for dynamic definition of cutoff_decr).
bonmin.cutoff                                  Specify cutoff value.
bonmin.cutoff_decr                             Specify cutoff decrement.
bonmin.delete_redundant                        Eliminate redundant variables, which appear in the problem as x_k = x_h
bonmin.dynamic_def_cutoff_decr                 Do you want to define the parameter cutoff_decr dynamically?
bonmin.enable_dynamic_nlp                      Enable dynamic linear and quadratic rows addition in nlp
bonmin.feasibility_pump_objective_norm         Norm of feasibility pump objective function
bonmin.file_solution                           Write a file bonmin.sol with the solution
bonmin.first_perc_for_cutoff_decr              The percentage used when, the coeff of variance is smaller than the threshold, to compute the cutoff_decr dynamically.
bonmin.heuristic_RINS                          if yes runs the RINS heuristic
bonmin.heuristic_dive_MIP_fractional           if yes runs the Dive MIP Fractional heuristic
bonmin.heuristic_dive_MIP_vectorLength         if yes runs the Dive MIP VectorLength heuristic
bonmin.heuristic_dive_fractional               if yes runs the Dive Fractional heuristic
bonmin.heuristic_dive_vectorLength             if yes runs the Dive VectorLength heuristic
bonmin.heuristic_feasibility_pump              whether the heuristic feasibility pump should be used
bonmin.integer_tolerance                       Set integer tolerance.
bonmin.iteration_limit                         Set the cumulated maximum number of iteration in the algorithm used to process nodes continuous relaxations in the branch-and-bound.
bonmin.log_num_abt_per_level                   Specify the frequency (in terms of nodes) for aggressive bound tightening.
bonmin.log_num_obbt_per_level                  Specify the frequency (in terms of nodes) for optimality-based bound tightening.
bonmin.lp_log_level                            specify LP log level.
bonmin.max_consecutive_failures                (temporarily removed) Number $n$ of consecutive unsolved problems before aborting a branch of the tree.
bonmin.max_consecutive_infeasible              Number of consecutive infeasible subproblems before aborting a branch.
bonmin.max_fbbt_iter                           Number of FBBT iterations before stopping even with tightened bounds.
bonmin.max_random_point_radius                 Set max value r for coordinate of a random point.
bonmin.maxmin_crit_have_sol                    Weight towards minimum in of lower and upper branching estimates when a solution has been found.
bonmin.maxmin_crit_no_sol                      Weight towards minimum in of lower and upper branching estimates when no solution has been found yet.
bonmin.milp_solver                             Choose the subsolver to solve MILP sub-problems in OA decompositions.
bonmin.milp_strategy                           Choose a strategy for MILPs.
bonmin.min_number_strong_branch                Sets minimum number of variables for strong branching (overriding trust)
bonmin.nlp_failure_behavior                    Set the behavior when an NLP or a series of NLP are unsolved by Ipopt (we call unsolved an NLP for which Ipopt is not able to guarantee optimality within the specified tolerances).
bonmin.nlp_log_at_root                          Specify a different log level for root relaxtion.
bonmin.nlp_log_level                           specify NLP solver interface log level (independent from ipopt print_level).
bonmin.nlp_solver                              Choice of the solver for local optima of continuous nlp's
bonmin.node_comparison                         Choose the node selection strategy.
bonmin.node_limit                              Set the maximum number of nodes explored in the branch-and-bound search.
bonmin.num_cut_passes                          Set the maximum number of cut passes at regular nodes of the branch-and-cut.
bonmin.num_cut_passes_at_root                  Set the maximum number of cut passes at regular nodes of the branch-and-cut.
bonmin.num_iterations_suspect                  Number of iterations over which a node is considered "suspect" (for debugging purposes only, see detailed documentation).
bonmin.num_resolve_at_infeasibles              Number $k$ of tries to resolve an infeasible node (other than the root) of the tree with different starting point.
bonmin.num_resolve_at_node                     Number $k$ of tries to resolve a node (other than the root) of the tree with different starting point.
bonmin.num_resolve_at_root                     Number $k$ of tries to resolve the root node with different starting points.
bonmin.num_retry_unsolved_random_point         Number $k$ of times that the algorithm will try to resolve an unsolved NLP with a random starting point (we call unsolved an NLP for which Ipopt is not able to guarantee optimality within the specified tolerances).
bonmin.number_before_trust                     Set the number of branches on a variable before its pseudo costs are to be believed in dynamic strong branching.
bonmin.number_before_trust_list                Set the number of branches on a variable before its pseudo costs are to be believed during setup of strong branching candidate list.
bonmin.number_look_ahead                       Sets limit of look-ahead strong-branching trials
bonmin.number_strong_branch                    Choose the maximum number of variables considered for strong branching.
bonmin.number_strong_branch_root               Maximum number of variables considered for strong branching in root node.
bonmin.oa_cuts_log_level                       level of log when generating OA cuts.
bonmin.oa_cuts_scope                           Specify if OA cuts added are to be set globally or locally valid
bonmin.opt_window                              Window around known optimum
bonmin.optimality_bt                           Optimality-based (expensive) bound tightening (OBBT)
bonmin.pump_for_minlp                          if yes runs FP for MINLP
bonmin.quadrilinear_decomp                     type of decomposition for quadrilinear terms (see work by Cafieri, Lee, Liberti)
bonmin.random_point_perturbation_interval      Amount by which starting point is perturbed when choosing to pick random point by perturbating starting point
bonmin.random_point_type                       method to choose a random starting point
bonmin.read_solution_file                      Read a file with the optimal solution to test if algorithms cuts it.
bonmin.redcost_bt                              Reduced cost bound tightening
bonmin.resolve_on_small_infeasibility          If a locally infeasible problem is infeasible by less than this resolve itwith initial starting point.
bonmin.second_perc_for_cutoff_decr             The percentage used when, the coeff of variance is greater than the threshold, to compute the cutoff_decr dynamically.
bonmin.setup_pseudo_frac                       Proportion of strong branching list that has to be taken from most-integer-infeasible list.
bonmin.solution_limit                          Abort after that much integer feasible solution have been found by algorithm
bonmin.sos_constraints                         Wether or not to activate SOS constraints.
bonmin.time_limit                              Set the global maximum computation time (in secs) for the algorithm.
bonmin.tiny_element                            Value for tiny element in OA cut
bonmin.tree_search_strategy                    Pick a strategy for traversing the tree
bonmin.trust_strong_branching_for_pseudo_cost  Whether or not to trust strong branching results for updating pseudo costs.
bonmin.use_auxcons                             Use constraints-defined auxiliaries, i.e. auxiliaries w = f(x) defined by original constraints f(x) - w = 0
bonmin.use_quadratic                           Use quadratic expressions and related exprQuad class
bonmin.use_semiaux                             Use semiauxiliaries, i.e. auxiliaries defined as w >= f(x) rather than w := f(x))
bonmin.variable_selection                      Chooses variable selection strategy
bonmin.very_tiny_element                       Value for very tiny element in OA cut
bonmin.warm_start                              Select the warm start method
bound_frac                                     Desired minimal relative distance of initial point to bound
bound_mult_init_val                            Initial value for the bound multipliers
bound_push                                     Desired minimal absolute distance of initial point to bound
bound_relax_factor                             Factor for initial relaxation of the bounds
compl_inf_tol                                  Acceptance threshold for the complementarity conditions
constr_mult_init_max                           Maximal allowed least-square guess of constraint multipliers
constr_viol_tol                                Desired threshold for the constraint violation
diverging_iterates_tol                         Threshold for maximal value of primal iterates
dual_inf_tol                                   Desired threshold for the dual infeasibility
expect_infeasible_problem                      Enable heuristics to quickly detect an infeasible problem
file_print_level                               Verbosity level for output file
halt_on_ampl_error                             Exit with message on evaluation error
hessian_approximation                          Can enable Quasi-Newton approximation of hessian
honor_original_bounds                          If no, solution might slightly violate bounds
linear_scaling_on_demand                       Enables heuristic for scaling only when seems required
linear_solver                                  Linear solver to be used for step calculation
linear_system_scaling                          Method for scaling the linear systems
ma27_pivtol                                    Pivot tolerance for the linear solver MA27
ma27_pivtolmax                                 Maximal pivot tolerance for the linear solver MA27
ma57_pivot_order                               Controls pivot order in MA57
ma57_pivtol                                    Pivot tolerance for the linear solver MA57
ma57_pivtolmax                                 Maximal pivot tolerance for the linear solver MA57
max_cpu_time                                   CPU time limit
max_iter                                       Maximum number of iterations
max_refinement_steps                           Maximal number of iterative refinement steps per linear system solve
max_soc                                        Maximal number of second order correction trial steps
maxit                                          Maximum number of iterations (same as max_iter)
min_refinement_steps                           Minimum number of iterative refinement steps per linear system solve
mu_init                                        Initial value for the barrier parameter
mu_max                                         Maximal value for barrier parameter for adaptive strategy
mu_oracle                                      Oracle for a new barrier parameter in the adaptive strategy
mu_strategy                                    Update strategy for barrier parameter
nlp_scaling_max_gradient                       Maximum gradient after scaling
nlp_scaling_method                             Select the technique used for scaling the NLP
obj_scaling_factor                             Scaling factor for the objective function
option_file_name                               File name of options file (default: ipopt.opt)
outlev                                         Verbosity level (same as print_level)
output_file                                    File name of an output file (leave unset for no file output)
pardiso_matching_strategy                      Matching strategy for linear solver Pardiso
pardiso_out_of_core_power                      Enables out-of-core version of linear solver Pardiso
print_level                                    Verbosity level
print_options_documentation                    Print all available options (for ipopt.opt)
print_user_options                             Toggle printing of user options
required_infeasibility_reduction               Required infeasibility reduction in restoration phase
slack_bound_frac                               Desired minimal relative distance of initial slack to bound
slack_bound_push                               Desired minimal absolute distance of initial slack to bound
tol                                            Desired convergence tolerance (relative)
wantsol                                        solution report without -AMPL: sum of
                1 ==> write .sol file
                2 ==> print primal variable values
                4 ==> print dual variable values
                8 ==> do not print solution message
warm_start_bound_push                          Enables to specify how much should variables should be pushed inside the feasible region
warm_start_init_point                          Enables to specify bound multiplier values
warm_start_mult_bound_push                     Enables to specify how much should bound multipliers should be pushed inside the feasible region
watchdog_shortened_iter_trigger                Trigger counter for watchdog procedure